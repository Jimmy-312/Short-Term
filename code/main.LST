C51 COMPILER V9.01   MAIN                                                                  07/26/2021 22:14:59 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include<reg52.h>
   2          #include<intrins.h>
   3          #include<codetab.h>
   4          #include<LQ12864.h>
   5          #define uint unsigned int
   6          #define uchar unsigned char
   7          
   8          #define Nack 10                                                                         //Number of retransmissions in temperature measurement communication
   9          #define ACK(); SDA=0;NOP_3();SCL=1;NOP_3();SCL=0;       //ACK signal
  10          
  11          /*Address of the temperature threshold in the EEPROM*/
  12          #define Thread1 0x01   
  13          #define Thread2 0x02   
  14          #define Thread3 0x03
  15          
  16          /*Address definition in EEPROM*/
  17          #define Hisn 0x00                                       //History pointer
  18          #define EEPDa 0x04                                      //data head
  19          #define Naddr 0x30                                      //current name data
  20          #define Nowaddr 0xE0                            //history name data
  21          
  22          /*pin definition*/   
  23          sbit RS=P1^2;             
  24          sbit RW=P1^1;          
  25          sbit LCDE=P1^0;
  26          sbit LED=P1^6;
  27          sbit BUZZ=P1^7;
  28          sbit INT2=P3^5; 
  29          sbit DC=P1^5;         
  30          
  31          /*bit flag definition*/
  32          bdata uchar flag;
  33          sbit bit_out=flag^1;
  34          sbit bit_in=flag^0;
  35          sbit sta=flag^2;                //Temperature measurement flag bit       
  36          sbit set=flag^3;                        //Threshold setting flag bit
  37          sbit his=flag^4;                        //History flag bit
  38          sbit sw=flag^5;                         //History display refresh flag bit
  39          sbit setw=flag^6;                       //Threshold up bit
  40          sbit setd=flag^7;                       //Threshold display refresh flag bit
  41          
  42          bdata uchar flag2;
  43          sbit setm=flag2^0;                  //Threshold down bit
  44          sbit bluea=flag2^1;                     //Bluetooth active bit
  45          sbit xname=flag2^2;                     //Edit name bit
  46          sbit blues=flag2^3;                     //Bluetooth send bit
  47          sbit psend=flag2^4;         //Bluetooth send method bit
  48          
  49          /*EEPROM data and flag*/
  50          uchar bdata EEP;
  51          sbit EEP_7 = EEP^7;
  52          sbit EEP_0 = EEP^0; 
  53          
  54          /*LCD function definition*/
  55          void busy(void);                                                //check if busy
C51 COMPILER V9.01   MAIN                                                                  07/26/2021 22:14:59 PAGE 2   

  56          void cmd_w(uchar cmd);                                  //write the command
  57          void init1602(void);                                    //initial the LCD
  58          void dat_wrt(uchar dat);                                //wtite the data
  59          void LCD_print(uchar *str,uchar n);             //display the str
  60          
  61          /*EEPROM function definition*/
  62          void I2C_Ack(void);                                             //wait the reply
  63          void I2C_Start(void);                                   //start signal
  64          void I2C_Stop(void);                                    //stop signal
  65          void Write_Byte(uchar wdata);                   //write a byte
  66          uchar Read_Byte(void);                                  //read a byte
  67          uchar eread(uchar addr);                                //read a byte data 
  68          void ewrite(uchar addr,uchar dat);              //write a byte data
  69          void ewrstr(uchar addr,uchar* str);             //wrtie a str
  70          void erdstr(uchar addr);                                //read a str
  71          
  72          /*MLX90614 function definition*/
  73          void i2c_Init(void);                                    //initial  IIC
  74          void start_bit(void);                                   //start signal
  75          void stop_bit(void);                                    //stop signal
  76          void send(uchar dat_byte);                              //write a byte
  77          void send_bit(void);                                    //write a bit
  78          uchar read(void);                                               //read a byte
  79          void receive_bit(void);                                 //read a bit
  80          uint gettemp(void);                                             //get the target temp
  81          void getETemp(void);                                    //get the evironment temp
  82          void mtemp(void);                                               //measure module
  83          
  84          /*Bluetooth function definition*/
  85          void ConfigUART(uint baud);                             //initial
  86          void BlueSend(uchar *str);                              //send a str
  87          void BlueReceive();                                             //receive a str
  88          
  89          /*custom function definition*/
  90          void inital();                                          //initial everything
  91          void time1int();                                        //timer 1 initial
  92          void dismain();                                         //display the mainpage
  93          void hisswitch(void);                           //history switching
  94          void SendHis();                                         //Send all history record
  95          void sta_mode();                                        //Measure mode
  96          void set_mode();                                        //threadhold set mode
  97          void his_mode();                                        //history record view mode
  98          void edit_name();                                       //edit user name 
  99          
 100          /*Variable Definition*/
 101          uint count=0;                             //counter
 102          uchar flag1;                              //transport use byte
 103          uchar evt[7];                             //store the environment temp
 104          uchar RxdB;                                       //store the sbuf
 105          uint tem;                                         //store the temp
 106          float otem;                                       //store the original temp
 107          uint temthread;                           //store the temp treadhold
 108          uchar hisnum;                             //store the history index
 109          uchar s[10];                              //store the str mostly
 110          uchar sn[9];                              //store the name str
 111          uchar sel;                                        //store the history record select index
 112          uchar td[3];                              //store the threadhold in array
 113          uchar index[2];                           //store the history record index str
 114          uchar temH,temL,err;              //store the original temp (vvvvvvvery original) and some useless things
 115          
 116          void main()
 117          {
C51 COMPILER V9.01   MAIN                                                                  07/26/2021 22:14:59 PAGE 3   

 118   1              inital();
 119   1              
 120   1              while(1)           //main loop
 121   1              {    
 122   2                      if(sta)
 123   2                      {
 124   3                              sta_mode();                             //Various modes are included here for switching
 125   3                      }
 126   2                      else if(set)
 127   2                      {
 128   3                              set_mode();
 129   3                      }
 130   2                      else if(his)
 131   2                      {       
 132   3                              his_mode();
 133   3                      }
 134   2                      else
 135   2                      {
 136   3                              if(xname){ 
 137   4                                      edit_name();
 138   4                              }
 139   3                      }
 140   2              }
 141   1      }
 142          
 143          ////////////////Function module//////////////
 144          void sta_mode()
 145          {
 146   1              LCD_print("  Result:",1);
 147   1              OLED_CLS();
 148   1              OLED_P8x16Str(0,0,"Result:");
 149   1              mtemp();
 150   1              getETemp();                                                        //Temperature measurement and display
 151   1              sta=0;
 152   1              LCD_print(s,0);
 153   1              OLED_P8x16Str(56,0,s);
 154   1              LCD_print("       Evn: ",0);
 155   1              OLED_P8x16Str(0,2,"Evn:");
 156   1              OLED_P8x16Str(32,2,evt);
 157   1              LCD_print(evt,0);
 158   1              if(tem>temthread){                      //Alert module
 159   2                      BUZZ=0;
 160   2                      LED=0;
 161   2                      delay(1000);
 162   2                      BUZZ=1;
 163   2                      LED=1;
 164   2      
 165   2                      OLED_P16(0,4,7);
 166   2                      OLED_P16(16,4,8);
 167   2              }else{
 168   2                      OLED_P16(0,4,19);
 169   2                      OLED_P16(16,4,20);
 170   2              }  
 171   1              
 172   1              hisnum++;
 173   1              if(hisnum==9)
 174   1                      hisnum=1;                                 //loop store
 175   1              
 176   1              ewrite(Hisn,hisnum);
 177   1          ewrite(EEPDa+hisnum*3,tem/1000);  
 178   1          ewrite(EEPDa+hisnum*3+1,tem % 1000/100);             //Storing data to EEPROM
 179   1              ewrite(EEPDa+hisnum*3+2,tem%100/10); 
C51 COMPILER V9.01   MAIN                                                                  07/26/2021 22:14:59 PAGE 4   

 180   1      
 181   1              ewrstr(Naddr+hisnum*8,sn);
 182   1              delay(2000);
 183   1              dismain();
 184   1      }
 185          
 186          void set_mode(){
 187   1              uchar i;
 188   1              if(!setd)                                                  //display module
 189   1              {
 190   2                      s[0]=td[0]+0x30;
 191   2                      s[1]=td[1]+0x30;
 192   2                      s[3]=td[2]+0x30;
 193   2                      s[2]='.';
 194   2                      s[4]='C';
 195   2                      s[5]=0;
 196   2                      LCD_print("   Set:",1);
 197   2                      LCD_print(s,0);
 198   2                      OLED_CLS();
 199   2                      OLED_P8x16Str(0,0,"Set:");
 200   2                      OLED_P8x16Str(32,0,s);
 201   2                      setd=1;
 202   2                      OLED_P16(0,4,9);
 203   2                      for(i=0;i<4;i++)
 204   2                              OLED_P16(i*16+16,4,9+i);
 205   2              }
 206   1              if(setw)                                        //up the treadhold
 207   1              {
 208   2                      td[2]+=1;
 209   2                      if(td[2]==10)
 210   2                      {
 211   3                              td[1]+=1;
 212   3                              td[2]=0;
 213   3                      }
 214   2                      ewrite(Thread3,td[2]);
 215   2                      ewrite(Thread2,td[1]);
 216   2                      temthread=td[0]*1000+td[1]*100+td[2]*10;
 217   2                      setd=0;
 218   2                      setw=0;
 219   2              }
 220   1              if(setm)                                                //down the treadhold
 221   1              {
 222   2                      if(td[2]==0)
 223   2                      {
 224   3                              td[1]-=1;
 225   3                              td[2]=10;
 226   3                      }
 227   2                      td[2]-=1;
 228   2                      ewrite(Thread3,td[2]);
 229   2                      ewrite(Thread2,td[1]);
 230   2                      temthread=td[0]*1000+td[1]*100+td[2]*10;
 231   2                      setd=0;
 232   2                      setm=0;
 233   2              }
 234   1      }
 235          
 236          void his_mode()
 237          {
 238   1              if(sw)
 239   1              {
 240   2                      if(sel==0)
 241   2                              sel=8;                                                           //display module
C51 COMPILER V9.01   MAIN                                                                  07/26/2021 22:14:59 PAGE 5   

 242   2                      s[0]=eread(EEPDa+sel*3)+0x30;
 243   2                      s[1]=eread(EEPDa+sel*3+1)+0x30;
 244   2                      s[3]=eread(EEPDa+sel*3+2)+0x30;
 245   2                      s[2]='.';
 246   2                      s[4]='C';
 247   2                      s[5]='\0';
 248   2      
 249   2                      if(sel<=hisnum){
 250   3                              index[0]=hisnum+1-sel+0x30;
 251   3                      }else{
 252   3                              index[0]=9+hisnum-sel+0x30;
 253   3                      }
 254   2                      LCD_print(" History: ",1);      
 255   2                      OLED_CLS();
 256   2                      OLED_P8x16Str(0,0,"History:");
 257   2                      erdstr(Naddr+sel*8); 
 258   2                      LCD_print(s,0);
 259   2                      OLED_P8x16Str(64,0,s);
 260   2                      LCD_print("   ",0);
 261   2                      index[1]=0;
 262   2                      LCD_print(index,0);
 263   2                      OLED_P8x16Str(0,2,index);
 264   2                      LCD_print("  ",0);
 265   2                      OLED_P8x16Str(24,2,sn);
 266   2                      LCD_print(sn,0);        
 267   2                      sw=0;   
 268   2                      sel--;             
 269   2              }
 270   1              if(bluea)                                                          //send module
 271   1              {
 272   2                      OLED_CLS();
 273   2                      LCD_print("   Bluetooth A",1);
 274   2                      OLED_P8x16Str(0,0,"Bluetooth A");
 275   2                      OLED_P16(0,2,13);
 276   2                      OLED_P16(16,2,14);
 277   2                      OLED_P16(32,2,15);
 278   2                      OLED_P16(48,2,16);
 279   2                      while(bluea&&blues);                            //exit judge
 280   2                      if(!bluea)
 281   2                              goto bback;
 282   2                      bluea=0;
 283   2                      blues=1;
 284   2                      OLED_P8x16Str(0,4,"Sending...");
 285   2                      LCD_print("       Sending...",0);
 286   2                      SendHis();
 287   2                      LCD_print("   Bluetooth            OK!",1);
 288   2                      OLED_P8x16Str(0,6,"OK!");                                                        //send module
 289   2                      BUZZ=0;
 290   2                      delay(500);
 291   2                      BUZZ=1; 
 292   2                      EX0=1;
 293   2                      EX1=1;
 294   2      bback:  LED=1;
 295   2                      time1int();                             
 296   2                      sel=hisnum;
 297   2                      sw=1;
 298   2              }
 299   1      }
 300          
 301          void edit_name()
 302          {
 303   1                      BlueReceive();
C51 COMPILER V9.01   MAIN                                                                  07/26/2021 22:14:59 PAGE 6   

 304   1                      if(!xname)
 305   1                              goto bbback;             //exit judge
 306   1                      ewrstr(Nowaddr,s);
 307   1                      xname=0;  
 308   1                      erdstr(Nowaddr);
 309   1                      LCD_print(sn,0);
 310   1                      OLED_P8x16Str(40,0,sn);
 311   1                      cmd_w(0x4C+0x80);
 312   1                      LCD_print("OK!",0);                              //receive module
 313   1                      OLED_P8x16Str(0,2,"OK!");
 314   1                      delay(2000);
 315   1      bbback: time1int();
 316   1                      dismain();
 317   1      }
 318          
 319          void SendHis()
 320          {       
 321   1              uchar i,j;
 322   1              EX0=0;
 323   1              EX1=0;
 324   1              j=hisnum;
 325   1              for(i=0;i<8;i++,j--)                      //loop send the 8 record
 326   1              {
 327   2                      if(j==0)
 328   2                              j=8;
 329   2                      s[0]=eread(EEPDa+j*3)+0x30;
 330   2                      s[1]=eread(EEPDa+j*3+1)+0x30;
 331   2                      s[3]=eread(EEPDa+j*3+2)+0x30;
 332   2                      s[2]='.';
 333   2                      s[4]='C';
 334   2                      s[5]=0x20;
 335   2                      s[6]=i+1+0x30;
 336   2                      s[7]=0x20;
 337   2                      s[8]=0;
 338   2                      BlueSend(s);
 339   2                      erdstr(Naddr+j*8);
 340   2                      BlueSend(sn);
 341   2                      s[0]='\r';                                      //line break
 342   2                      s[1]='\n';
 343   2                      s[2]=0;
 344   2                      BlueSend(s);
 345   2              }
 346   1              s[0]='O';
 347   1              s[1]='K';
 348   1              s[2]='!';
 349   1              s[3]='\0';
 350   1              BlueSend(s);
 351   1      }
 352          
 353          //////////////initalized module//////////////////
 354          void dismain()
 355          {
 356   1              uchar i;
 357   1              OLED_CLS();
 358   1              erdstr(Nowaddr);
 359   1              LCD_print(sn,1);
 360   1              OLED_P8x16Str(0,0,sn);
 361   1              cmd_w(0x88);                                                                     //welcome display and some initial
 362   1              LCD_print("Welcome!  Press to START",0);
 363   1              OLED_P8x16Str(0,2,"Welcome!");
 364   1              OLED_P8x16Str(0,4,"Press to START");
 365   1              for(i=0; i<7; i++)
C51 COMPILER V9.01   MAIN                                                                  07/26/2021 22:14:59 PAGE 7   

 366   1              {
 367   2                      OLED_P16(i*16,6,i);                                              //loop for Chinese characters
 368   2              }
 369   1      }
 370          
 371          void time1int()
 372          {
 373   1              ES=0;
 374   1              TMOD &= 0x0F;
 375   1              TMOD |= 0x60;                            //timer 1 initial, use for interrupting
 376   1              TH1=0xFF;
 377   1              TL1=0xFF;
 378   1              ET1=1;
 379   1              TR1=1;
 380   1      }
 381          
 382          void inital()
 383          {
 384   1              EX0 = 1;        
 385   1          IT0 = 1;                
 386   1          EX1 = 1;        
 387   1          IT1 = 1;
 388   1              EA=1; 
 389   1              sta=0;
 390   1              his=0;
 391   1              sw=0;                                            //some default value
 392   1              setw=0;
 393   1              setd=0;
 394   1              xname=0;
 395   1              bluea=0;
 396   1              setm=0;
 397   1              sta=0;
 398   1              set=0;
 399   1              DC=0;
 400   1              blues=1;
 401   1              psend=0;
 402   1      
 403   1              time1int();                                     //time1 and screen initial
 404   1              init1602();
 405   1              OLED_Init();
 406   1              //ewrite(Hisn,0);        
 407   1              td[0]=eread(Thread1);
 408   1              td[1]=eread(Thread2);                                     //get the temp threadhold
 409   1              td[2]=eread(Thread3);
 410   1              temthread=td[0]*1000+td[1]*100+td[2]*10;
 411   1              hisnum=eread(Hisn);     
 412   1              dismain();
 413   1      }
 414          
 415          ////////////////////interrupt module////////////////////
 416          void int0() interrupt 0
 417          {
 418   1              delay(100);
 419   1              if(INT0==0)
 420   1              {
 421   2                      if(his)
 422   2                      {
 423   3                              //LED=1;
 424   3                              if(bluea){
 425   4                                      if(INT2==0){                                              //transport mode switcher
 426   5                                              psend=~psend;
 427   5                                              OLED_CLS();
C51 COMPILER V9.01   MAIN                                                                  07/26/2021 22:14:59 PAGE 8   

 428   5                                              if(!psend){
 429   6                                                      LCD_print("   Bluetooth A",1);
 430   6                                                      OLED_P8x16Str(0,0,"Bluetooth A");
 431   6                                                      OLED_P16(0,2,13);
 432   6                                                      OLED_P16(16,2,14);
 433   6                                                      OLED_P16(32,2,15);
 434   6                                                      OLED_P16(48,2,16);
 435   6                                              }else{
 436   6                                                      LCD_print("   Bluetooth B",1);
 437   6                                                      OLED_P8x16Str(0,0,"Bluetooth B");
 438   6                                                      OLED_P16(0,2,17);
 439   6                                                      OLED_P16(16,2,18);
 440   6                                                      OLED_P16(32,2,15);
 441   6                                                      OLED_P16(48,2,16);
 442   6                                              }
 443   5                                      }else{
 444   5                                              bluea=0;                        //exit send
 445   5                                      }
 446   4                              }else{
 447   4                                      set=1;
 448   4                                      setd=0;                            //switch to set
 449   4                                      his=0;
 450   4                              }
 451   3                      }else
 452   2                      if(set){
 453   3                              set=0;
 454   3                              his=0;                                    //switch to homepage
 455   3                              dismain();
 456   3                      }else{
 457   3                              if(xname){
 458   4                                      xname=0;                          //exit edit name
 459   4                              }else{
 460   4                                      his=1;
 461   4                                      //LED=0;
 462   4                                      sel=hisnum;                        //switch to history mode
 463   4                                      sw=1;
 464   4                              }
 465   3                      }
 466   2              }
 467   1      }
 468          
 469          void int1() interrupt 2
 470          {
 471   1              uchar i;
 472   1              delay(100);
 473   1              if(INT1==0)
 474   1              {
 475   2                      if(his)
 476   2                      {
 477   3                              if(bluea){
 478   4                                      blues=0;                        //start send
 479   4                              }else{
 480   4                                      sw=1;                           //switch record
 481   4                              }                       
 482   3                      }else
 483   2                      if(set)
 484   2                      {
 485   3                              if(INT0==0){
 486   4                                      ewrite(Thread1,3);
 487   4                                      ewrite(Thread2,7);                        //reset temp threadhold
 488   4                                      ewrite(Thread3,6);
 489   4                                      td[0]=eread(Thread1);
C51 COMPILER V9.01   MAIN                                                                  07/26/2021 22:14:59 PAGE 9   

 490   4                                      td[1]=eread(Thread2);
 491   4                                      td[2]=eread(Thread3);
 492   4                                      setw=1;
 493   4                                      setd=0;
 494   4                                      return;
 495   4                              }
 496   3                              if(INT2==0){
 497   4                                      LCD_print("Create By Jimmy     2021.7.25",1);
 498   4                                      OLED_CLS();
 499   4                                      OLED_P8x16Str(0,0,"Create By Jimmy");                   //display the author info
 500   4                                      OLED_P8x16Str(0,2,"2021.7.26");
 501   4                                      for(i=0; i<8; i++)
 502   4                                      {
 503   5                                              OLED_P16x16(i*16,6,i);
 504   5                                      }
 505   4                                      delay(5000);
 506   4                                      inital();
 507   4                                      return;
 508   4                              }
 509   3                              setw=1;                                   //up threadhold
 510   3                      }else{
 511   3                              if(xname){
 512   4                                      xname=0;                 //exit edit name
 513   4                              }else{
 514   4                                      sta=1;                   //switch to homepage
 515   4                              }
 516   3                      }
 517   2              }
 518   1      } 
 519          
 520          void int2() interrupt 3
 521          {
 522   1              delay(100);
 523   1              if(INT2==0)
 524   1              {
 525   2                      if(his)
 526   2                      {
 527   3                              if(bluea){
 528   4      
 529   4                              }else{
 530   4                                      bluea=1;                        //enter in the record send --- Bluetooth default mode A
 531   4                                      LED=0;
 532   4                                      ConfigUART(9600);
 533   4                              }                               
 534   3                      }else
 535   2                      if(set)
 536   2                      {
 537   3                              setm=1;                                  //down threadhold
 538   3                      }else{
 539   3                              xname=1;
 540   3                              OLED_CLS();
 541   3                              LCD_print("Name: ",1);                    //enter the name edit
 542   3                              OLED_P8x16Str(0,0,"Name:");
 543   3                              ConfigUART(9600);
 544   3                      }
 545   2              }
 546   1      } 
 547          
 548          /////////////////Temperature measurement module////////////////
 549          void mtemp(void)
 550          {
 551   1              uchar i;
C51 COMPILER V9.01   MAIN                                                                  07/26/2021 22:14:59 PAGE 10  

 552   1              tem=0;
 553   1              i2c_Init();
 554   1              for(i=0;i<10;i++)
 555   1                      tem=tem+gettemp();                      //measure 10 times and get the average value
 556   1                      delay(10);
 557   1              otem=tem/1000;
 558   1              tem=100*(otem*otem*otem*(-0.0012)+0.1719*otem*otem+125.7-7.06719*otem);                    //temp conversion formula
 559   1              s[0]=tem/1000+0x30;
 560   1              s[1]=tem % 1000/100+0x30;
 561   1              s[2]=0x2E;
 562   1              s[3]=tem%100/10+0x30;                            //int2str
 563   1              s[4]=0x43;
 564   1              s[5]='\0';
 565   1      }
 566          
 567          uint getTemp(void)
 568          {
 569   1              start_bit();
 570   1              send(0xB4);                        //IIC address
 571   1              send(0x07);                        //Ram address
 572   1              start_bit();
 573   1              send(0x01);
 574   1              bit_out=0;                                 //read
 575   1              temL=read();
 576   1              bit_out=0;
 577   1              temH=read();
 578   1              bit_out=1;
 579   1              err=read();
 580   1              stop_bit();
 581   1              return (temH*256+temL)*2-27315;                  //initial conversion formula
 582   1      }
 583          
 584          void getETemp(void)
 585          {
 586   1              uint temtem;
 587   1              start_bit();
 588   1              send(0xB4); 
 589   1              send(0x06);                       //Ram address
 590   1              start_bit();
 591   1              send(0x01);
 592   1              bit_out=0;                                //the same as before
 593   1              temL=read();
 594   1              bit_out=0;
 595   1              temH=read();
 596   1              bit_out=1;
 597   1              err=read();
 598   1              stop_bit();
 599   1              temtem=(temH*256+temL)*2-27315;
 600   1              evt[0]=temtem/1000+0x30;
 601   1              evt[1]=temtem%1000/100+0x30;
 602   1              evt[2]='.';                                                             //int2str
 603   1              evt[3]=temtem%100/10+0x30;
 604   1              evt[4]='C';
 605   1              evt[5]=0;
 606   1      }
 607          
 608          ///////////////MLX90614 transport module/////////////////
 609          void i2c_Init(void)
 610          {
 611   1              SCL=1;
 612   1              SDA=1;
 613   1              _nop_();
C51 COMPILER V9.01   MAIN                                                                  07/26/2021 22:14:59 PAGE 11  

 614   1              _nop_();                                   //initial signal
 615   1              _nop_();
 616   1              _nop_();
 617   1              SCL=0;
 618   1              delay(1);
 619   1              SCL=1;
 620   1      }
 621          
 622          void start_bit(void)
 623          {
 624   1              SDA=1;
 625   1              _nop_();_nop_();_nop_();_nop_();_nop_();
 626   1              SCL=1;
 627   1              _nop_();_nop_();_nop_();_nop_();_nop_();
 628   1              SDA=0;
 629   1              _nop_();_nop_();_nop_();_nop_();_nop_();                         //follow the transport protocols
 630   1              SCL=0;
 631   1              _nop_();_nop_();_nop_();_nop_();_nop_();
 632   1      }
 633          
 634          void stop_bit(void)
 635          {
 636   1              SCL=0;
 637   1              _nop_();_nop_();_nop_();_nop_();_nop_();
 638   1              SDA=0;
 639   1              _nop_();_nop_();_nop_();_nop_();_nop_();                         //follow the transport protocols
 640   1              SCL=1;
 641   1              _nop_();_nop_();_nop_();_nop_();_nop_();
 642   1              SDA=1;
 643   1      }
 644          
 645          void send(uchar dat_byte)
 646          {
 647   1              char i,n,dat;
 648   1              n=Nack;
 649   1      send:
 650   1              dat=dat_byte;
 651   1              for(i=0;i<8;i++)
 652   1              {
 653   2                      if(dat&0x80)
 654   2                              bit_out=1;                                //follow the transport protocols
 655   2                      else
 656   2                              bit_out=0;
 657   2                      send_bit();
 658   2                      dat=dat<<1;
 659   2              }
 660   1              receive_bit();
 661   1              if(bit_in==1)
 662   1              {
 663   2                      stop_bit();
 664   2                      if(n!=0)
 665   2                      {
 666   3                              n--;
 667   3                              goto Repeat;                    //resend the signal
 668   3                      }
 669   2              }
 670   1              goto exit;
 671   1      Repeat:
 672   1              start_bit();
 673   1              goto send;
 674   1      exit: ;
 675   1      }
C51 COMPILER V9.01   MAIN                                                                  07/26/2021 22:14:59 PAGE 12  

 676          
 677          void send_bit(void)
 678          {
 679   1              if(bit_out==0)
 680   1                      SDA=0;
 681   1              else
 682   1                      SDA=1;
 683   1              _nop_();
 684   1              SCL=1;                                                                     //follow the transport protocols
 685   1              _nop_();_nop_();_nop_();_nop_();
 686   1              _nop_();_nop_();_nop_();_nop_();
 687   1              SCL=0;
 688   1              _nop_();_nop_();_nop_();_nop_();
 689   1              _nop_();_nop_();_nop_();_nop_();
 690   1      }
 691          
 692          uchar read(void)
 693          {
 694   1              uchar i,dat;
 695   1              dat=0;
 696   1              for(i=0;i<8;i++)
 697   1              {
 698   2                      dat=dat<<1;                                             //follow the transport protocols
 699   2                      receive_bit();
 700   2                      if(bit_in==1)
 701   2                              dat=dat+1;
 702   2              }
 703   1              send_bit();
 704   1              return dat;
 705   1      }
 706          
 707          void receive_bit(void)
 708          {
 709   1              SDA=1;bit_in=1;
 710   1              SCL=1;
 711   1              _nop_();_nop_();_nop_();_nop_();
 712   1              _nop_();_nop_();_nop_();_nop_();
 713   1              bit_in=SDA;                                                               //follow the transport protocols
 714   1              _nop_();
 715   1              SCL=0;
 716   1              _nop_();_nop_();_nop_();_nop_();
 717   1              _nop_();_nop_();_nop_();_nop_();
 718   1      }
 719          
 720          /////////////Bluetooth module/////////////////
 721          void BlueSend(uchar *str)
 722          {
 723   1              uchar i=0;
 724   1              while(str[i]!=0){
 725   2                      TI=0;
 726   2      Resend: SBUF=str[i];                       //send a byte
 727   2                      delay(50);
 728   2                      if(psend){
 729   3                              count=0;
 730   3                              while(!RI){
 731   4                                      count++;
 732   4                                      if(count>50000)                         //resend module
 733   4                                              goto Resend;
 734   4                              }
 735   3                              RI=0; 
 736   3                      }
 737   2                      i++;                                                                   
C51 COMPILER V9.01   MAIN                                                                  07/26/2021 22:14:59 PAGE 13  

 738   2              }
 739   1      }
 740          
 741          void BlueReceive()
 742          {
 743   1              uchar i=0;
 744   1              while(xname){
 745   2                      while(!RI&&xname);
 746   2                      if(!xname)
 747   2                              return;                                   //receive the new name
 748   2                      RxdB=SBUF;
 749   2                      RI=0;
 750   2                      if(RxdB=='@')
 751   2                              break;
 752   2                      s[i++]=RxdB;
 753   2              }
 754   1              s[i]=0;
 755   1      }
 756          
 757          void ConfigUART(unsigned int baud)
 758          {
 759   1              SCON = 0x50; 
 760   1              TMOD &= 0x0F; 
 761   1              TMOD |= 0x20;                                                                   //initial com bps
 762   1              TH1 = 256 - (11059200/12/32)/baud; 
 763   1              TL1 = TH1; 
 764   1              ET1 = 0; 
 765   1              ES = 1; 
 766   1              TR1 = 1; 
 767   1      }
 768          
 769          void InterruptUART() interrupt 4
 770          {
 771   1              if (RI) 
 772   1              {
 773   2              //      bluea=0;
 774   2              //      SBUF=1;
 775   2              //      delay(30);                                                 //useless
 776   2              }
 777   1              if (TI) 
 778   1              {
 779   2              //      TI = 0; 
 780   2              }
 781   1      }
 782          
 783          /////////////LCD module/////////////
 784          void cmd_w(uchar cmd)                                  
 785          {
 786   1              busy();                                                 
 787   1              P2=cmd;                                                 
 788   1              RS=0;                      //follow the transport protocols                              
 789   1              RW=0;                                                    
 790   1              LCDE=1;                                               
 791   1              LCDE=0;
 792   1      }
 793          
 794          void init1602(void)                            
 795          {
 796   1              cmd_w(0x01);                  //follow the transport protocols               
 797   1              cmd_w(0x0c);                               
 798   1              cmd_w(0x06);
 799   1              cmd_w(0x38);  
C51 COMPILER V9.01   MAIN                                                                  07/26/2021 22:14:59 PAGE 14  

 800   1      }
 801                                         
 802          void busy(void)                                
 803          {
 804   1              flag1=0x80;                                    
 805   1              while(flag1&0x80)                          
 806   1              {
 807   2                      P2=0xff;                                           //follow the transport protocols
 808   2                      RS=0;                                               
 809   2                      RW=1;                                             
 810   2                      LCDE=1;                                       
 811   2                      flag1=P2;                                       
 812   2                      LCDE=0;
 813   2              }
 814   1      }
 815          
 816          void dat_w(uchar dat)                                  
 817          {
 818   1              busy();                                               
 819   1              if(flag1==16)
 820   1              {       
 821   2                      P2=0xC0;
 822   2                  RS=0;                                               
 823   2                  RW=0;                       //follow the transport protocols                                         
             -                        
 824   2                  LCDE=1;                                               
 825   2                  LCDE=0;
 826   2              }
 827   1              P2=dat;
 828   1              RS=1;                                                       
 829   1              RW=0;                                                                                                    
             - 
 830   1              LCDE=1;                                                   
 831   1              LCDE=0;
 832   1      }
 833          
 834          void LCD_print(uchar *str,uchar n)                                      
 835          {
 836   1              if(n)
 837   1                      cmd_w(0x01);
 838   1              while(*str!='\0')                                   
 839   1              {                                                                                 //send str byte by byte
 840   2                      dat_w(*str);                                  
 841   2                      str++;                                                
 842   2              }
 843   1      }
 844          
 845          ////////////EEPROM//////////////
 846          void I2C_Ack(void)              
 847          {
 848   1              uchar i;
 849   1              SCL=1;
 850   1              delay(1);
 851   1              while((SDA==1)&&(i<255)) i++;                             //follow the transport protocols
 852   1              SCL=0;
 853   1              delay(1);
 854   1              SDA=1;
 855   1      }
 856          
 857          void I2C_Start(void)
 858          {
 859   1              SDA=1;
C51 COMPILER V9.01   MAIN                                                                  07/26/2021 22:14:59 PAGE 15  

 860   1              delay(1);
 861   1              SCL=1;                                                                    //follow the transport protocols
 862   1              delay(1);
 863   1              SDA=0;
 864   1              delay(1);
 865   1              SCL=0;
 866   1                      
 867   1      }
 868          
 869          void I2C_Stop(void)
 870          {
 871   1              SDA=0;
 872   1              delay(1);
 873   1              SCL=1;
 874   1              delay(1);                                                        //follow the transport protocols
 875   1              SDA=1;
 876   1              delay(1);       
 877   1      }
 878          
 879          void Write_Byte(uchar wdata)   
 880          {
 881   1              uchar i;
 882   1              EEP=wdata;
 883   1              for(i=0;i<8;i++)
 884   1              {       
 885   2                      SDA=EEP_7;
 886   2                      SCL=1;
 887   2                      delay(1);
 888   2                      EEP<<=1;                                          //follow the transport protocols
 889   2                      SCL=0;
 890   2                      delay(1);
 891   2              }
 892   1              SDA=1;
 893   1              delay(1);
 894   1              SCL=0;
 895   1      }
 896          
 897          uchar Read_Byte(void)    
 898          {
 899   1              uchar i;
 900   1              SDA=1;
 901   1              EEP=0;
 902   1              for(i=0;i<8;i++)
 903   1              {
 904   2                      EEP<<=1;                                 //follow the transport protocols
 905   2                      SCL=1;
 906   2                  delay(1);
 907   2                      EEP_0=SDA;
 908   2                      SCL=0;
 909   2                      delay(1);
 910   2              }
 911   1              return EEP;
 912   1      }
 913          
 914          void ewrite(uchar addr,uchar dat)
 915          {
 916   1              I2C_Start();
 917   1              Write_Byte(0xa0);
 918   1              I2C_Ack();
 919   1              Write_Byte(addr);  
 920   1              I2C_Ack();
 921   1              Write_Byte(dat);                                   //follow the transport protocols
C51 COMPILER V9.01   MAIN                                                                  07/26/2021 22:14:59 PAGE 16  

 922   1              I2C_Ack();
 923   1              I2C_Stop();
 924   1      }
 925          
 926          uchar eread(uchar addr)
 927          {
 928   1              uchar dat;
 929   1              I2C_Start();
 930   1              Write_Byte(0xa0);
 931   1              I2C_Ack();
 932   1              Write_Byte(addr);  
 933   1              I2C_Ack();
 934   1              I2C_Start();                                            //follow the transport protocols
 935   1              Write_Byte(0xa1);
 936   1              I2C_Ack();
 937   1              dat=Read_Byte();
 938   1              I2C_Stop();
 939   1              return dat;
 940   1      }
 941          
 942          void erdstr(uchar addr)
 943          {
 944   1              uchar i=0;
 945   1              do{      
 946   2                      sn[i]=eread(addr+i);                      //read str byte by byte
 947   2                      i++;    
 948   2              }while(sn[i-1]!=0);
 949   1      }
 950          
 951          void ewrstr(uchar addr,uchar* str)
 952          {
 953   1              uchar i=0;
 954   1              do{
 955   2                      ewrite(addr+i,str[i]);                    //write str byte by byte
 956   2                      i++;
 957   2              }while(str[i-1]!=0);
 958   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4150    ----
   CONSTANT SIZE    =   2693    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     51      39
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
